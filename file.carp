(relative-include "file_helper.h")

(deftype File [name String, mode String, file (Ptr FILE)])
(deftype WalkOptions [
  recursive? Bool,
  follow-links? Bool,
  dotfiles? Bool,
  match-dirs? Bool,
])

(defmodule WalkOptions
  (register RECURSIVE Int "WS_RECURSIVE")
  (register FOLLOWLINK Int "WS_FOLLOWLINK")
  (register DOTFILES Int "WS_DOTFILES")
  (register MATCHDIRS Int "WS_MATCHDIRS")

  (defn to-int [o]
    (Int.bit-or (if @(recursive? o) RECURSIVE 0)
      (Int.bit-or (if @(follow-links? o) FOLLOWLINK 0)
        (Int.bit-or (if @(dotfiles? o) DOTFILES 0)
                    (if @(match-dirs? o) MATCHDIRS 0)))))
)

(doc File "A simple file abstraction for Carp.

## Installation

You can obtain this library like so:

```
(load \"git@github.com:carpentry-org/file@0.0.6\")
```

## Usage

The main type involved in working with this library is `File`, naturally. All
file operations depend on the file being opened.

```
; returns a Result containing a File you can write to
(File.open \"example.txt\")

; returns a Result containing a File you append to
(File.open-with \"example.txt\" \"a\")
```

If the file couldn’t be opened due to it not existing or file permission errors,
a `Result.Error` with an error message is returned.

The file permissions follow the [file modes](https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm)
in UNIX. The default is `\"a+\"`, or writing/reading. Generally, files have a
`name`, `mode`, and `file` property; you can read safely from them, but writing
to them directly is discouraged.

Before you end your operations on the file, it is good practice to close the
file again. In Carp, we do this using `close`.

```
(close f)
```

You can `read` from the file—or `read-all`, if you don’t care about length—,
`write` to it, `remove` it, or `rewind` the file buffer.

```
(write &f \"hi\")
(rewind &f)
(IO.println &(read-all &f))
```

All of these will check whether the files are actually readable and/or writable
before performing any IO actions and return a `Result.Error` if they can’t.

You can also ask about the modes of the file, using the functions `readable?`,
`writable?`, or `binary-mode?`.")

(defmodule File
  (hidden OK)
  (register OK Int "WALK_OK")
  (hidden NAME-TOO-LONG)
  (register NAME-TOO-LONG Int "WALK_NAMETOOLONG")
  (hidden CANT-OPEN)
  (register CANT-OPEN Int "WALK_CANTOPEN")
  (hidden CANT-STAT)
  (register CANT-STAT Int "WALK_CANTSTAT")
  (hidden walk-internal)
  (register walk-internal (Fn [&String (Fn [String] ()) Int] Int) "walk_dir")

  (doc default-walk "is the default options used by [`walk`](#walk).

Initially set to recursive, not following links, and not matching directories or
dotfiles.")
  (def default-walk (WalkOptions.init true false false false))

  (doc walk-mode "constructs a mode for [`walk-with`](#walk-with).")
  (defn walk-mode [recursive? follow-links? dotfiles? match-dirs?]
    (WalkOptions.init recursive? follow-links? dotfiles? match-dirs?))

  (doc walk-with "walks a directory with a custom [walk mode](#walk-mode).

Returns a result containing either nothing, or an error if the directory
couldn’t be opened due to permission errors or if the user tried to open a
nonexistant directory.

It will currently fail when being passed a lambda which accesses any closure
variables due to a limitation of the Carp compiler.")
  (defn walk-with [s callback options]
    (case (walk-internal s @callback (WalkOptions.to-int options))
      OK (Result.Success 0)
      NAME-TOO-LONG (Result.Error (fmt "Filename '%s' too long" s))
      CANT-OPEN (Result.Error (fmt "Can’t open '%s'" s))
      CANT-STAT (Result.Error (fmt "Can’t stat '%s'" s))
      (Result.Error @"Unknown file error")))

  (doc walk "walks a directory with the default walk mode (see also
[`default-walk`](#default-walk)).

Returns a result containing either nothing, or an error if the directory
couldn’t be opened due to permission errors or if the user tried to open a
nonexistant directory.

It will currently fail when being passed a lambda which accesses any closure
variables due to a limitation of the Carp compiler.")
  (defn walk [s callback]
    (walk-with s callback &default-walk))

  (hidden contents-res)
  (private contents-res)
  (def contents-res (the (Array String) []))

  (doc contents-with "walks a directory with a custom [walk mode](#walk-mode).

Returns a result containing either the directory contents or an error if the
directory couldn’t be opened due to permission errors or if the user tried to
open a nonexistant directory.

It will currently fail when being passed a lambda which accesses any closure
variables due to a limitation of the Carp compiler.")
  (defn contents-with [s options]
    (do
      (set! contents-res [])
      (Result.map
        (walk-with s &(fn [f] (Array.push-back! &contents-res f)) options)
        (fn [_] @&contents-res))))

  (doc contents "walks a directory with the default walk mode (see also
[`default-walk`](#default-walk)).

Returns a result containing either the contents of that directory or an error
if the directory couldn’t be opened due to permission errors or if the user
tried to open a nonexistant directory.

It will currently fail when being passed a lambda which accesses any closure
variables due to a limitation of the Carp compiler.")
  (defn contents [s]
    (contents-with s &default-walk))

  (doc default-mode "is the default file mode, used by [`open`](#open).

Initially set to `a+`.")
  (def default-mode "a+")

  (doc readable? "checks whether a file is readable by examining its mode.")
  (defn readable? [f]
    (or (> (String.index-of (mode f) \+) -1)
        (> (String.index-of (mode f) \r) -1)))

  (doc writable? "checks whether a file is writable by examining its mode.")
  (defn writable? [f]
    (or (> (String.index-of (mode f) \w) -1)
        (> (String.index-of (mode f) \a) -1)))

  (doc binary-mode? "checks whether a file is in binary mode by examining its
mode.")
  (defn binary-mode? [f]
    (> (String.index-of (mode f) \b) -1))

  (doc open-with "opens a file with custom file mode.

Returns a result containing either a file, or an error if the file couldn’t be
opened due to permission errors or if the user tried to read from a nonexistant
file.")
  (defn open-with [name mode]
    (let [f (IO.fopen name mode)]
      (if (null? f)
        (Result.Error (fmt "File “%s” could not be opened!" name))
        (Result.Success (init @name @mode (IO.fopen name mode))))))

  (doc open "opens a file with the default file mode (see also
[`default-mode`](#default-mode)).

Returns a result containing either a file, or an error if the file couldn’t be
opened due to permission errors or if the user tried to read from a nonexistant
file.")
  (defn open [name]
    (open-with name default-mode))

  (doc close "closes a file and takes ownership.")
  (defn close [f]
    (IO.fclose @(file &f)))

  (doc remove "removes a file from the file system.")
  (defn remove [f]
    (IO.unlink @(name f)))

  (doc write "writes a string `string` to a file.

Returns a result containing nothing on success and an error if the file is not
writable.")
  (defn write [f string]
    (if (writable? f)
      (let-do [ln (length string)]
        (IO.fwrite (cstr string) 1 ln @(file f))
        (Result.Success 0))
      (Result.Error (fmt "The file “%s” is not writable" (name f)))))

  (doc write "reads a string of length `len` from a file.

Returns a result containing the string on success and an error if the file is
not readable.")
  (defn read [f len]
    (if (readable? f)
      (let-do [s (String.allocate len (Char.from-int 0))]
        (ignore (IO.fread (cstr &s) 1 len @(file f)))
        (Result.Success s))
      (Result.Error (fmt "The file “%s” is not readable" (name f)))))

  (doc write "reads the entire file content of a file.

Returns a result containing the string on success and an error if the file is
not readable.")
  (defn read-all [f]
    (let-do [fd @(file f)]
      (IO.fseek fd 0 IO.SEEK-END)
      (let-do [len (IO.ftell fd)]
        (IO.fseek fd 0 IO.SEEK-SET)
        (read f len))))

  (doc rewind "rewinds a file.")
  (defn rewind [f]
    (IO.rewind @(file f)))
)
